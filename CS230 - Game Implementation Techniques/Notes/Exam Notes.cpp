gameStateList.h - consist of the gamestate required
gameStateMgr.cpp - level manager. Manager and controller of how to change levels

Lecture 1: RTIS
========================================
Concurrent
----------
- Many events happening at same time 
    ▫ Objects moving
    ▫ Testing for input
    ▫ Sound effects
    ▫ Collision tests
    ▫ AI
    ▫ Updating HUD
    ▫ etc..
    
Interactive:
------------
Players decide:
    ▫ When & where to move the ship
    ▫ When & where to shoot a bullet
    ▫ Scores are updated while playing
    ▫ AI reacts to players’ actions

Real-Time:
---------
- When objects move, their positions are calculated at run time
    • Collision are determined at run time
    • HUDs are updated at run time

Game Loop:
----------
1 game loop = 1 game iteration = frame time = 1sec/60 = 0.016sec or 16.66ms

game speed = fps = 60fps
1 second update 60 times

- Game iteration is long(slow), 0.1sec, simulation will feel slow because the even only happens 10times in one second. 
- Game iteration is short(fast), 0.016sec, simulation will feel smooth because the reaction happens 60 times in one second. 
- Duration of game iteration is called frame time. 
- Game speed measure by frames per second 
- e.g. game speed is 60 frames per second/fps or f/s, game iteration is 16.66ms

- if game 60fps, game iteration is 1/60 = 16.66ms
- if game 10fps, game iteration is 1/10 = 0.1ms

- if game iteration is 0.1ms, game fps = 1/0.1 = 10fps
- if game iteration is 16.66ms, game fps = 1/16.66ms = 60fps

- higher fps, the smoother the visuals
- 120 fps for the smoothest experience but fps need to be machine tested. 

frame base gameloop vs timebased gameloop:
- if rely on time, the bullet will reach same position regardless of fps
- if rely on fps, then 10fps will only run 10 times. 60fps will run 60 times and bullet will travel further.

1. Input (use mouse, move camera, press key)
2. Logic (Is the space key pressed? mouse key pressed?
3. Physics (movements)
4. Collision 
5. Audio
6. Graphics 

Game Loop(1/60)
{
    //start time
    
    Input.Update
    Logic
    Physics
    Collision
    Audio
    Graphics
}

delta time = start - end time

Game flow: 
---------
1. Initialise game 
2. Initialise starting time 
3. Read player input 
4. Handling - Computing the new position for every object based on: Behaviour, Collision, Physics, Artificial Intelligence 
5. Draw - Render the image one object at a time to a buffer. 
6. Copy the buffer content to the video memory in order to display the frame
7. Check if time is less than 16.66ms. 
8. if Yes, do nothing. 
9. If No, back to Initialise starting time. 

Resolution:
----------
Pixel:
- Smallest element of a picture
- the higher the number of pixel in an image, the better the resolution
- Screen Resolution defined by the number of pixel across and down delivered by the display card circuitury
- graphic card can hold 640*480 and not more than 1600*1200

Colour:
- Red, green, blue 
- Red = 0, Green = 0, Blue = 0 produce black
- Full red, green and blue produce white 

Colour bit mode: 
- 8 Bit (2^8 = 256 colours)
- 16 Bit (2^16 = 65,536 colours)
- 24 Bit (2^24 = 16,777 colours)
- 32 Bit (2^32 = 4,294,967,295 colours)

CRT Concept:
- Cathode Ray Tube 
- Electron gun shoots electron that accelerates as beam
- Direction of beam is controlled by 2 pairs of deflection plates or by magnetic field generated by coils
- red, green and blue 
- Output from the computer is converted by a digital-to-analog converter
- Electron gun shoots electrons at all the phosphor targets, sequentially
- Timing:
    ▫ H-Blank is time needed to raster the next row
    ▫ V-Blank is time needed to go from the last pixel of the last line to the first pixel of the first line
    • Problem: Phosphors are lit for a very short amount of time
    
- Solution: Image must be refreshed at least 50 times a second
    ▫ Called: Refresh rate of the monitor. Measured in Hz

- Interlaced:
    ▫ Odd numbered lines are refreshed during one frame
    ▫ Even numbered lines are refreshed during the next one, and so on…

- Difference between interlaced and non-interlaced
    o The refresh cycle of the interlaced display monitor is divided into two frames.
    o All the odd-numbered scan lines are displayed in the first frame, and the remaining lines are displayed in the second frame.
    o When those two frames are drawn in succession, the mind creates an image of the combination of the frames.
    o The non-interlaced display monitor refreshes all horizontal lines sequentially.
    
Refresh Rate:
- The number of times, per second, that image are refreshed on the display 
- measured in hertz. 
- 60 hertz is acceptable level 
- DO NOT CONFUSE WITH FRAME RATE. Frame rate measures the speed a video source can provide an entire frame for the display
- Example:
    o The frame rate of a movie is usually 24, which means it has 24 different frames each second
    o But movie projectors usually have a 48 or 72 Hz refresh rate, which means they project the same frame twice or three times before projecting the next frame
    
Refresh Rate & Frame Rate
• The monitor and the video card do not have to be in sync
• Each time the monitor needs to refresh itself, it takes the content of the primary frame buffer and displays it
▫ Frame buffer: Array of colors found on the video card

Refresh rate different from FPS:
- Tearing effect will take place 


Vertical Sync (vSync):
----------------------
- Sync the graphic card to the monitor's refresh rate
- Make graphic card wait for V-Blank 
- Works well if game frame rate higher than monitor refresh rate
- 

- if game frame rate not higher than monitor refresh rate 
    - skips monitors V-Blank, therefore must wait for next one
    - Monitor displays each image twice
    - Game FPS drops to 30 (half the monitor refresh rate), (1/3 if monitor refresh rate is already before 30)


LCD Montiors:

Lecture 2: Game Engine Component
========================================
System Component and Game Logic Component. 

System Component - Hardware
Game Logic Component - Game Logic

System Component:
-----------------
▫ Frame Rate Controller
▫ Memory Manager
▫ File Manager
▫ Graphics Manager
▫ Audio Manager
▫ Input Manager

Frame Rate Controller:
----------------------
• Has two primary jobs:
    ▫ To ensure a consistent frame rate for the current game state and decide when the frame buffer should be swapped
▫ Tracks useful information:
    - Number of frames since the game started
    - Number of frames since the game state started
    - How much time the last frame used (in seconds)

Memory Manager:
---------------
• Features that a memory manager should have:
    ▫ Optimized memory allocation/deallocation for the game
    ▫ Hierarchical memory heap
    ▫ Easy way to track memory usage
    ▫ Simpler way to track memory leaks
    ▫ Runtime memory de-fragmentation

File Manager:
-------------
• Features that a file manager should have:
▫ Background file loading
▫ Decompress data during load time
▫ Automatic file sharing
• File managers run on a different thread

Graphic Manager:
----------------
- A layer on top of the graphic hardware 
    - Graphic Manager <-> Direct 3D or OpenGL <-> GPU (graphic processing unit)

Audio Manager:
--------------
- Deals with sound hardware 
    - Audio Manager <-> X3DAudio or OpenAL <->Hardware(e.g. Speakers)
    
Input Manager:
--------------
• The input manager keeps track, among other things:
    ▫ Current pressed keys
    ▫ Newly pressed keys
    ▫ Newly released keys
    ▫ A history of pressed keys 

Game Logic Component:
---------------------
Game State Manager
▫ Simulation Manager
▫ Collision Detection Manager
▫ Object Manager
▫ Environment Manager
▫ Camera System

Game State Manager:
-------------------
- Responsible for game state switching, the game loop and the frame rate controller
- Each state is associated with a set or functions that manages that states cycle 

-The cycle functions are:
▫ Load
▫ Initialize
▫ Update
▫ Draw
▫ Free
▫ Unload

Simulation Manager:
------------------
• It’s the physics component of the engine
• Deals with the kinematics and dynamics of the game objects

Collision Detection Manager:
----------------------------
• Takes care of the objects’ impact and their collision updates
• Collision systems might be written from simple mathematical intersection functionalities to a complex partitioned collision sections
    ▫ Quadtree
    ▫ Octree
    ▫ BSP Tree
    ▫ Etc…

Object manager:
---------------
Objects that are “Alive” are managed by the object manager that is responsible for:
▫ Loading game objects and initialize them
▫ Create and remove object instances
▫ Updating objects
▫ Sending object’s data to the graphics manager

Environment manager:
--------------------
The environment manager deals with static objects.
• Static objects are objects that the user does not interact with directly


Managing System Components:
- Set up input device 
- Set up video device
- Set up audio device
- Allocate video buffers 
- Decide some part of pipeline done using software or hardware 

Camera System:
--------------
- Sounds very simple, yet, a bad camera could practically turn a perfectly good game into horrible game.
- There are four parameters commonly used to control the camera
    ▫ CamPosition
    ▫ CamTarget
    ▫ CamUp
    ▫ CamFOV

Memory Manager:

Lecture 3
========================================
Game State Manager (GSM)
------------------------
• A game is always in a state. A game could be in “Main Menu”, in “Level 1”, in “Loading screen”…
• The GSM is responsible for game state switching, the game loop and the frame rate controller.
• Each state is associated with a set of functions that manages that state’s cycle.

The cycle functions are:
▫ Load
▫ Initialize
▫ Update
▫ Draw
▫ Free
▫ Unload

Cycle Functions: Load:
----------------------
• Loads the state’s necessary data and initializes it.
• It is called once at the start of the state.
• It should NOT be called upon restarting a state.

Cycle Functions: Initialize
• Used to prepare the state’s data in order to be used for the first time.
• It loads no data whatsoever.
• If a state is restarted, this cycle function is used.

Cycle Functions: Update 
-----------------------
▫ Updates the state’s data, based on several factors like user input, time or gameplay logic…

Cycle Function: Draw
--------------------
▫ Sends data to the graphics engine component

Cycle Functions: Free
---------------------
• Used to clean up the state.
• Make the state ready to be unloaded or initialized again.
• No data is dumped in this cycle function

Cycle Functions: Unload
-----------------------
• Is called when the state should be terminated.
• It dumps back all the data that was loaded in the state’s load cycle function.

Lectuure 4
========================================

Lecture 5
========================================
Procedural Programming:
-----------------------
- One consequences: 
    1. there is one main program that is responsible for controlling its sub program
  
- Nevertheless, the application is still responsible for controlling its subprograms and not the user. 
  
Event driven Programming:
-------------------------
- By adding user input to the application, it makes it interactive. 

Difference:
-----------
In event driven programming
    -is calling event handlers in the application 
    -Instructions not executed sequentially from first to last 
    -Application does not know which functions are invoked
    -Applcation decides which events to handle 

Lecture 6
========================================

Lecture 7
========================================

Lecture 8 
========================================
Scaling:
--------
|scaleX     0   0|
|   0   scaleY  0|
|   0       0   1|

- double the size, scaleX and scaleY to 2 
- reduce size by half, scaleX and scaleY to 1/2
- if want to scale sprite size by certain factor, set scaleX and scaleY to 1/number

- Scale, rotate then translate 

Rotate:
-------
|cos(a) -sin(a) 0|
|sin(a)  cos(a) 0|
| 0      0      1|

-Usually, if want to rotate point A around centre C, translate A to tally with centre(0,0), apply rotation, then translate back original position

-In order to avoid 2 extra translation, just need to rotate sprite in local coordingate system before applying translation matrix

2 ways to rotate object after frame:
------------------------------------
1. Rotate original object by absolute rotation value
2. Rotate object from previous frame orientation using an incremental value

- Do not use float for rotation

- better to make angle a hold the current absolute angle of rotation of the sprite and not an incremental value 
- Therefore, it should always be the current rotation angle of the sprite, not the difference between previous and the current one

Translation:
------------
|1  0   X|
|0  1   Y|
|0  0   1|

- X and Y are real world position and not incremental values, means translate 2D point from (0,0) to (X:Y)
- this matrix translate any point by X axis and by Y on Y-axis
- However, when a spite moves, its position should always hold its current absolute world position, not the difference between previous and current 

Translation(2x2):
-----------------
x' = x+dx
y' = y+dy

P = |x|     P' = |x'|   T = |dx| 
    |y|          |d'|       |dy|
    
P' = P + T

- Translation cannot be represented as 2x2 matrix

Scaling(2x2):
-------------
x' = Sx*x
y' = Sy*x

|x| = |Sx   0||x| or P' = S*P
|y|   |0   Sy||y|

Rotation(2x2): 
--------------
x = Rcos(b)
y = Rsin(b)

x' = Rcos(a+b) 
   = Rcos(b)cos(a) - Rsin(b)sin(a)
   = xcos(a) - ysin(a)
   
y' = Rcos(a+b) 
   = Rcos(b)*cos(a) + Rsin(b)*cos(a)
   = xsin(a) + ycos(a)

rotation matrix: 
   
|cos(a)  -sin(a)||x|
|sin(a)   cos(a)||y|    or P' = R*P

cos(-a) = cos(a)    sin(-a) = -sin(a)

Homogeneous:
------------
- use 3 points instead of 2

(x,y,z)

- for points use, z = 1. e.g. (6,4,1)
- for direction vector, z = 0.(point at infinite)

Scaling(3x3):
-------------
P' = S(Sx,Sy)*P

S(Sx,Sy) = |Sx  0   0|
           |0   Sx  0|
           |0   0   1|
           
Rotation(3x3):
--------------
P' = R(a)*P

R(a) = |cos(a)  -sin(a) 0|
       |sin(a)   cos(a) 0|
       |0           0   1|
       
Translation(3x3):
-----------------
P' = T(dx,dy)*P

T(dx,dy) = |1   0   dx|
           |0   1   dy|
           |0   0   1 |
              
Identity:
---------
|x| = |1    0   0||x|
|y|   |0    1   0||y|
|1|   |0    0   1||1|

Rigid-Body Transformation:
--------------------------
- Has the form: 

|cos(a) -sin(a) dy|
|sin(a)  cos(a) dy|
|0          0   1 |

- upper 3x3 matrix are orthogonal 
- Unit square after transformation will remain as a unit square

Affine Transformation:
----------------------
- Whats the product of an arbitrary sequence of rotation, translation and scale matrix? Ans: Affine transformation
- Has property of preserving parrallelism of lines but not length and angles (applies for sequence of rotation, scale, translation)

Composition of 2D transformation:
--------------------------------
- Purpose: Gain efficiency by applying single composed transformation to a point, rather than series of them

Rotation about some abitrary point:
-----------------------------------
- To rotate about abitrary point P(x,y)
- 1. Translate P by (-x, -y) (move to origin)
- 2. Rotate by a
- 3. Translate P by (x, y) (translate back)

Transformation is: 

T(x,y)*R(a)*T(-x,-y) = |1   0   x||cos(a)   -sin(a) 0||1    0   -x|
                       |0   1   y||sin(a)    cos(a) 0||0    1   -y|
                       |0   0   1||0            0   1||0    0    1|
                       
                     = |cos(a)  -sin(a) x(1-cos(a))+ysin(a)|
                       |sin(a)   cos(a) y(1-cos(a))+xsin(a)|
                       |0           0           1          |
                       
Scale about some abitrary point:
--------------------------------
T(x1,y1)*S(sx,sy)*T(-x1,-y1) = |1   0   x1||Sx  0   0||1    0   -x1|
                               |0   1   y1||0   Sy  0||0    1   -y1|
                               |0   0   1 ||0   0   1||0    0    1 |
                               
                             = |Sx  0   x1(1-Sx)|
                               |0   Sy  y1(1-Sy)|
                               |0   0       1   |
                               
Matrix Multiplication
---------------------
- Is Associative:

    C(B(Ax)) = C((BA)x) = (C(BA))x
                    = ((CB)A)x
                    = (CB)(Ax)
                    
- Not communtative (AB !=BA)
- (rotation then translation) != (translation then rotation)

Applying Tranformation Matrix:
------------------------------
T(x2,y2)*R(a)*S(Sx,Sy)*T(-x,-y)

1. Original
2. Translate to Origin
3. Scale
4. Rotate 
5. Translate to final position

Apply: how graphics tranform each vertex (posX,posY) from local to global space 

|posX'|   |1    0   dx| |cos(a)  -sin(a) 0| |Sx  0   0| |posX|
|posY'| = |0    1   dy|*|sin(a)   cos(a) 0|*|0   Sy  0|*|posY|
|  1  |   |0    0    1| |   0        0   1| |0   0   1| |  1 |

Application in Alpha Engine:
----------------------------
▫ AEMtx33 trans, rot, scale;
▫ AEMtx33Trans(&trans,dx, dy);//dx, dy are the position of the game object
▫ AEMtx33Rot(&rot, a);//Alpha is the orientation angle of the game object
▫ AEMtx33Scale(&scale,Sx,Sy);//sx, sy are the scale of the game object

▫ Concatenation of matrices (matrix multiplication)
▫ AEMtx33 result, m1, m2;
▫ AEMtx33Concat(&result, m1, m2);//this means: result = m1*m2
▫ Sending the result matrix to Alpha Engine graphics system
▫ AEGfxSetTransform(&result.m);//m is a matrix data representation

Lecture 18
========================================
Bounding Area:
--------------
- A single area simple area encapsulating one or more objects of more complex nature 
- Characters:
    • Inexpensive intersection tests
    • Tight fitting
    • Inexpensive to compute
    • Easy to rotate and transform
    • Use little memory

Bounding Circle, AABB, OBB, Convex Hull

- Better bounding, better culling  ----->
- Faster test, lesser memory       <-----

Bounding Rectangle:
-------------------
- 2D games uses bounding rectange around game object
- rectange should be as small as possible
- top, bottom, left and right 

struct AABB
{
    Point2 min;
    Point2 max;
}

Rectange & Rectange Collision
-----------------------------
- must overlap on both x and y axis

2 Static Rectanges
------------------

if(A.max < B.min|| A.min > B.max)
    return 0;                           //No intersection
else
    return 1;                           //overlapping rectangle

2 Moving Rectangles
------------------
- make 1 rectangle move
- make 1 rectangle stationary

relativeVelocity.x = vel2.x - vel1.x;
relativeVelocity.y = vel2.y - vel1.y;

B-> A 

tFirst = A.min - B.max 
tLast = A.max - B.min

case 1:     <-B     A
case 4:     A       <-B
case 2:     B->     A
case 3:     A       B->

Lecture 9
========================================
frame based:
-----------
Pos1+=v

velocity = v(3,0)

60 fps, move 180 unit per second
30 fps, move 90 unit per second
x fps, move 3x unit per second

Time based:
-----------
Pos1 = v*dt + Pos0

velocity = v(180,0)

60fps, move 180 unit per second
30fps, move 180 unit per second
x fps, move 180 unit per second


60fps, - - - - - - - - - - - - - - - - -
30fps, -   -   -   -   -   -   -   -   -

- Time based will always reach the same position but different step

- Smoothness of the movements
    - slow FPS will look as if its disaappearing and reappearing creating the illusion of motion. 

Velocity
-------
Velocity = Normalized Direction*speed 

next position = current position + speed*velocity*timestep

pos1 = pos0 + velocity*time

Acceleration:
-------------
Pos1 = (1/2*A*t*t) + (V0*t + Pos0)

v1 = a*t + v0
pos1 = v1 + pos0


Lecture 11
========================================
Snapping:
--------
PosX = (int)(PosX)+0.5
PosY = (int)(PosY)+0.5

Translate: (To center of screen)
--------------------------------
|1  0   -gridwidth/2 |
|0  1   -gridheight/2|
|0  0           1    |

Scale: (scale up to screen size)
--------------------------------


Lecture 12
========================================

kinetic energy = 1/2*mass*velocity*velocity
               = 1/2*mv^2
          




